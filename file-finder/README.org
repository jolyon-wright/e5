#+TITLE:README
#+AUTHOR:Jolyon Wright
#+EMAIL:jolyon.wright@gmail.com
# #+OPTIONS: toc:nil
# #+OPTIONS: num:nil
#+OPTIONS: author:nil date:nil
#+OPTIONS: ^:nil

#+OPTIONS: toc:20
#+OPTIONS: author:nil date:nil
# #+HTML_HEAD_EXTRA: <style>*{font-family: Liberation Mono; !important}</style>

#+HTML_HEAD: <style>pre.src {background-color: #303030; color: #e5e5e5;}</style>
#+HTML_HEAD: <style>p.verse {background-color: #D1EEEE;}</style>

#+LATEX: \setlength\parindent{0pt}
#+LATEX: \parskip=12pt % adds vertical space between paragraphs
#+LATEX_HEADER: \usepackage[inline]{enumitem}
#+LATEX_HEADER: \usepackage{extsizes}
#+LATEX_HEADER: \usepackage{xeCJK}
#+LATEX_HEADER: \setlist[itemize]{noitemsep}
#+LATEX_HEADER: \setlist[enumerate]{noitemsep}
#+LATEX_HEADER: \usepackage[margin=1in]{geometry}
#+LATEX_HEADER: \usepackage{graphicx,wrapfig,lipsum}
#+LATEX_HEADER: \documentclass[a4paper,8pt]{article}




* Synopsis

Please give me a shout if anything here is unclear!

Here are the files in the archive:-

#+ATTR_HTML: :border 2 :rules all :frame border
| File            | Description                     |
|-----------------+---------------------------------|
| file-finder.cpp | the source                      |
| CMakeLists.txt  | Cross Platform build generation |
| README.org      | these notes                     |
| README.html     | the org file as an HTML file    |

* How To Build
** Prerequisites
- cmake version 3.21.2 or above.
- a C++17 compiler and supported toolchain
** Generating makefiles or a Visual Studio Project
- invoke a command line environment configured for your build environment, for example the Visual Studio development prompt
- type:-
#+begin_src bash
  cmake .
#+end_src
** x64 Platforms checked for build and basic execution
  - Windows 10 with Visual Studio 2022
  - MacOs 12.2.1 with AppleClang 13.1.6.13160021
  - Ubuntu 2004 g++ 9.4.0

* Overview
** Requirements Conformance
- Your application must be written in either C or C++.
  - it was tempting to write this in C, on the basis that I am more familiar with the API, however using C++17 is much more interesting!
- Each substring will be serviced by a dedicated thread.
  - for each substring a substring_container::finder_proc thread is created.
    Each instance:-
    - recursively searches for each substring
    - adds it to the collection
    - checks if termination is requested
- The periodic dumper will be a dedicated thread.
  - the periodic_dumper_consumer thread is created, this:-
    - waits for termination request for 10 seconds
    - if termination is not requested dump_and_clear_records() is invoked
    - if termination is requested the thread will terminate
- A single container will be shared by all threads.
  - substring_container holds a single queue which is simultaneously accessed by all the threads
- You must ensure that your application releases all resources you allocated before you terminate - i.e. don't rely on program termination to clean things up.
  - All resource allocation is managed using RAII so no explicit cleanup is required, beyond the need to join() the threads.
** Main
The application's main thread:-
- creates the worker threads
- receives, validates and processes user input
- on input "Dump"
  - invokes the helper method dump_and_clear_records()
  - waits for input
- on input "Exit"
  - signals for termination
  - ceases waiting for input
- on invalid input
  - prints a helpful message
  - waits for input
- signals the termination request
- waits for thread termination


* Caveats
** Character encoding

#+begin_quote
Paths are encoded in your OS's native string representation.
#+end_quote

#+begin_quote
We encourage you to make simplifying assumptions rather than attempting to handle
every edge case. If you do so, please document them so we can see your reasoning
#+end_quote

This code is nominally cross platform so we should respect the OS string representation of the target platform.  This is problematic on Windows because, unlike Linux and MacOs, Windows native string is 16 bit unicode.

Because this is not the main point of the exercise I have not attempted to resolve this.  However [[https://www.boost.org/doc/libs/develop/libs/nowide/doc/html/index.html][boost.nowide]] would address this by allowing us to use utf8 on Windows.

** Style!
My C++ style is a bit unconventional, for example:-

#+begin_src C
  int
  main(int    argc,
       char** argv
       )
#+end_src

I am not going to attempt to defend it, but I am going to explain it, in the hope of leniency :)

Because the C++ code I have written is usually fairly tightly coupled with Windows driver code, the style is  influenced by Windows kernel coding conventions.  It's not a religious thing!

This has the benefit that the reader can easily skip from reading the user mode C++ to the driver code without too much mental gear shifting.

* "Miscellaneous Notes" Response
** How To Test
CMake and CTest work nicely with googletest and this could "easily" be integrated.

** Given more time...

This is very much a first pass; please be gentle!
I am particularly interested in understanding:-
  - if there are flaws in my understanding of these APIs
  - how this can be made more comprehensible
  - approaches to making the logic more encapsulated
  - if a higher level approach would be more appropriate

It would be nice to add logging, possibly boost.log.  During development I have used cout, which is not ideal.
