#+TITLE:README
#+AUTHOR:Jolyon Wright
#+EMAIL:jolyon.wright@gmail.com
#+OPTIONS: author:nil date:nil
#+OPTIONS: ^:nil

#+OPTIONS: toc:20
#+OPTIONS: author:nil date:nil
#+HTML_HEAD: <style>pre.src {background-color: #303030; color: #e5e5e5;}</style>
#+HTML_HEAD: <style>p.verse {background-color: #D1EEEE;}</style>

#+LATEX: \setlength\parindent{0pt}
#+LATEX: \parskip=12pt % adds vertical space between paragraphs
#+LATEX_HEADER: \usepackage[inline]{enumitem}
#+LATEX_HEADER: \usepackage{extsizes}
#+LATEX_HEADER: \usepackage{xeCJK}
#+LATEX_HEADER: \setlist[itemize]{noitemsep}
#+LATEX_HEADER: \setlist[enumerate]{noitemsep}
#+LATEX_HEADER: \usepackage[margin=1in]{geometry}
#+LATEX_HEADER: \usepackage{graphicx,wrapfig,lipsum}
#+LATEX_HEADER: \documentclass[a4paper,8pt]{article}




* Synopsis

Please give me a shout if anything here is unclear!

Here are the files in the archive:-

#+ATTR_HTML: :border 2 :rules all :frame border
| File            | Description                     |
|-----------------+---------------------------------|
| file-finder.cpp | the source                      |
| CMakeLists.txt  | Cross Platform build generation |
| README.org      | these notes                     |
| README.html     | the org file as an HTML file    |

* How To Build
** Prerequisites
- cmake version 3.21.2 or above.
- a C++17 compiler and supported toolchain
** Generating makefiles or a Visual Studio Project
- invoke a command line environment configured for your build environment, for example the Visual Studio development prompt
- type:-
#+begin_src bash
  cmake .
#+end_src
** x64 Platforms checked for build and basic execution
  - Windows 10 with Visual Studio 2022
  - MacOs 12.2.1 with AppleClang 13.1.6.13160021
  - Ubuntu 2004 with g++ 9.4.0

* Overview
** Requirements Conformance
- Your application must be written in either C or C++.
  - it was tempting to write this in C, on the basis that I am more familiar with the API, however using C++17 is much more interesting!
- Each substring will be serviced by a dedicated thread.
  - for each substring a substring_container::finder_proc thread is created.
    Each instance:-
    - recursively searches for each substring
    - adds it to the collection
    - checks if termination is requested
- The periodic dumper will be a dedicated thread.
  - the periodic_dumper_consumer thread is created, this:-
    - waits for termination request for 10 seconds
    - if termination is not requested dump_and_clear_records() is invoked
    - if termination is requested the thread will terminate
- A single container will be shared by all threads.
  - substring_container holds a single queue which is simultaneously accessed by all the threads
- You must ensure that your application releases all resources you allocated before you terminate - i.e. don't rely on program termination to clean things up.
  - All resource allocation is managed using RAII so no explicit cleanup is required, beyond the need to join() the threads.
** Main
The application's main thread:-
- creates the worker threads
- receives, validates and processes user input
- on input "Dump"
  - invokes the helper method dump_and_clear_records()
  - waits for input
- on input "Exit"
  - signals for termination
  - ceases waiting for input
- on invalid input
  - prints a helpful message
  - waits for input
- signals the termination request
- waits for thread termination


* Caveats
** Character encoding

#+begin_quote
Paths are encoded in your OS's native string representation.
#+end_quote

#+begin_quote
We encourage you to make simplifying assumptions rather than attempting to handle
every edge case. If you do so, please document them so we can see your reasoning
#+end_quote

This code is nominally cross platform so we should respect the OS string representation of the target platform.  This is problematic on Windows because, unlike Linux and MacOs, Windows native strings are 16 bit unicode.

In practice this will mean that paths that use non western characters will not work correctly.  This is more than an edge case; it's a big problem.

Because this is not the main point of the exercise I have not attempted to resolve this.  However [[https://www.boost.org/doc/libs/develop/libs/nowide/doc/html/index.html][boost.nowide]] would address this by allowing us to use utf8 on Windows.

** Style!
My C++ style, without coding standards, is a bit unconventional, for example:-

#+begin_src C
  int
  main(int    argc,
       char** argv
       )
#+end_src

I am not going to attempt to defend it, but I am going to explain it, in the hope of leniency :)

Because the C++ code I have written is usually fairly tightly coupled with Windows driver code, the style is  influenced by Windows kernel coding conventions.  It's not a religious thing!

Historically Windows kernel code was poorly documented and the only documentation was really the headers and sample code and so it was essential to penetrate the conventions and the easiest way was to adopt them.

This has the benefit that the reader can easily skip from reading the user mode C++ to the driver code without too much mental gear shifting.

* "Miscellaneous Notes" Response
** How To Test

Beyond basic tests, like valgrind on Linux and prefast and AppVerifier on Windows, this has not been well tested.  It really needs some unit tests… ideally written before the code…

CMake and CTest work nicely with googletest and this could "easily" be integrated.

** Given more time...
*** TODOs
This is very much a first pass; please be gentle!
- It would be good to adopt an approach where the flow of execution was clearer.  Unfortunately time constraints have meant that I have not had a chance to get beyond producing something that works; and I may be wrong about this.  I would welcome the chance to be proved wrong and learn the error of my ways.
- Scant regard has been paid to most of C++'s core concepts, like encapsulation and so forth; I'm afraid the primary objective has been "finish by Friday and don't forget about the day job!".
- The code is not well documented.  I figured it was more worthwhile putting together these notes, rather than detailing every parameter.
- Diagrams in these notes would make things clearer; a picture is worth a thousand words… but unfortunately getting org babel mode to play nicely with dot renditions would take a thousand hours.
- It would be nice to add logging, possibly boost.log.  During development I have used cout, which is not ideal.

***  Allocation of Available Time
In terms of time allocation, this has been divided about equally between:-
- writing code
- writing these notes
- testing

Hopefully this balance gives you something that is comprehensible, working and… fun! I would value thoughts on the most effective use of time to achieve this.

My thinking here is that, given no tests, the likelihood of producing something that works reliably is minimal so let's try and focus on producing a package that makes it easy-ish to get working on any platform and then understand why things don't work.

*** TO_UNDERSTANDs
I am particularly interested in understanding:-
- if there are flaws in my understanding of these APIs
- approaches to making the logic more encapsulated
- if a higher level approach would be more appropriate
- basically how we can leverage C++ to model the problem more closely…
